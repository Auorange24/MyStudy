# distributed-lock

## Redis的其他用法

+ 数据共享、分布式session，多个微服务使用同一session，可以存储在redis服务器中，进行获取。
+ 分布式锁
+ 全局ID，多个请求访问，得添加分布式锁吧。
+ 计算器、点赞
+ 位统计 
+ 购物车
+ 轻量级消息队列，list、stream
+ 抽奖
+ 点赞、签到、打卡 bitmap
+ 差集、交集、并集合、用户关注，可能认识的人，推荐模型
+ 热搜新闻、热搜排行榜，ZSET

多个微服务使用同一session，可以存储在redis服务器中，进行获取。

> TODO: session是什么？

## Why Need Distributed Lock

多个线程同时访问商品库存、外卖订单，会发生数据竞争，传统的锁是相对于一个进程来讲的，不适用于多个线程。

> dirty data



## 分布式锁应该具备哪些条件？

### 必备条件

+ **互斥**，任意一个时刻，锁只能被一个线程持有。
+ **高可用**，Lock Service是高可用的，当一个锁出现问题，能自动切换另外一个锁服务。即使客户端释放锁的代码出现问题，锁因为超时问题最终还是会被释放。
+ **可重入**，一个节点获取了锁之后，还能再次获取锁。

### 其他条件

+ **高性能**，Lock和UnLock的过程能快速完成，不会对整个系统的性能造成影响。
+ **非阻塞**，如果不能获取锁，不能够无限期等待。

## 分布式锁的常见实现方式

+ 基于关系型数据库，MySQL
+ 基于分布式协调服务，ZooKeeper
+ 基于分布式键值存储系统，Redis、Etcd

关系型数据库一般使用唯一索引或者排他锁实现，这种实现性能太差且不存在锁超时过期机制。


# 基于Redis实现分布式锁

## 如何使用Redis使用一个最简易的分布式锁

**互斥**

`SETNX`，如果成功设置KV，返回1。使用一个key-value代表锁，如果写入成功则表示获取锁，当释放锁时就把key-value删除，实现了分布式锁的互斥。

```lua
if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else 
    return 0
end
```

## 为什么要给锁设置一个过期时间

为了避免锁无法被释放，可以给锁设置一个过期时间。

```bash
SET lockkey uniqueValue EX 3 NX
```

+ `lockKey`，设置锁的锁名
+ `uniqueValue`，能够唯一标识锁的随机字符串
+ `NX`，仅当key不存在的时候才能SET成功。
+ `EX`，可以设置过期时间。

> Note
> 
> 保证设置key的值和设置过期时间是一个原子操作。不然的话，可能会出现锁无法被释放的问题。

## 如何实现锁的优雅续期

### 为什么要实现锁的优雅续期

如果获取分布式锁的操作之后，锁的时间到期了，但是数据操作还未进行完毕，则需要实现锁的续期。


## 使用ZooKeeper实现分布式锁的优点和缺点

**优点**

+ Zookeeper实现分布式锁拥有更高的可靠性。
+ Zookeeper拥有Watch机制，可以实现更加公平的分布式锁。

**缺点**

+ Zookeeper性能较差